diff --git a/gl_context.c b/gl_context.c
index abcdef1..1234567 100644
--- a/gl_context.c
+++ b/gl_context.c
@@ -385,60 +385,28 @@ void gl_render_frame(gl_context_t *gl, uint8_t *y_data, uint8_t *u_data, uint8_t *v_data, 
     }
     
     glClear(GL_COLOR_BUFFER_BIT);
-    
-    // Set up OpenGL state only once or when needed
-    if (!gl_state_set) {
-        glViewport(0, 0, drm->width, drm->height);
-        
 
-        
-        gl_state_set = true;
-    }
+    // CRITICAL: Complete buffer unbinding before state restoration
+    // This is needed to prevent state leakage from previous operations
+    glBindBuffer(GL_ARRAY_BUFFER, 0);
+    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
+    glUseProgram(0);
     
-    // CRITICAL: Always ensure correct state for video rendering
-    // Overlays can change program, buffers, textures, and other state
-    static bool render_state_set = false;
-    GLint current_program, current_vbo;
-    glGetIntegerv(GL_CURRENT_PROGRAM, &current_program);
-    glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &current_vbo);
-    bool state_corrupted = (current_program != (GLint)gl->program || 
-                           current_vbo != (GLint)gl->vbo);
+    // Reset vertex attribute arrays
+    glDisableVertexAttribArray(0);
+    glDisableVertexAttribArray(1);
     
-    // Always reset state after first frame or if corrupted by overlays
-    if (!render_state_set || frame_rendered == 0 || state_corrupted) {
-        if (state_corrupted && frame_rendered > 0) {
-            static int corruption_warnings = 0;
-            if (corruption_warnings < 3) {
-                printf("Video: Restoring corrupted OpenGL state (program: %d->%d, vbo: %d->%d)\n", 
-                       current_program, (int)gl->program, current_vbo, (int)gl->vbo);
-                
-                // Also check texture bindings
-                GLint bound_tex;
-                glActiveTexture(GL_TEXTURE0);
-                glGetIntegerv(GL_TEXTURE_BINDING_2D, &bound_tex);
-                printf("Video: Y texture binding: %d (expected %d)\n", bound_tex, (int)gl->texture_y);
-                
-                corruption_warnings++;
-            }
-        }
-        glUseProgram(gl->program);
-        
-
-        
-        // Bind buffers and set up vertex attributes (cached setup)
-        glBindBuffer(GL_ARRAY_BUFFER, gl->vbo);
-        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, gl->ebo);
-        
-        // Position attribute
-        glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)0);
-        glEnableVertexAttribArray(0);
-        
-        // Texture coordinate attribute  
-        glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)(2 * sizeof(float)));
-        glEnableVertexAttribArray(1);
-        
-        // Set MVP matrix (identity - only once)
-        float mvp_matrix[16] = {
+    // Now set up the correct state for video rendering
+    glUseProgram(gl->program);
+    glBindBuffer(GL_ARRAY_BUFFER, gl->vbo);
+    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, gl->ebo);
+    
+    // Set up vertex attributes
+    glEnableVertexAttribArray(0);
+    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)0);
+    
+    glEnableVertexAttribArray(1);
+    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)(2 * sizeof(float)));
+    
+    // Explicitly disable blending - overlays might have enabled it
+    glDisable(GL_BLEND);
+    
+    // Disable depth test - make sure video is always visible
+    glDisable(GL_DEPTH_TEST);
+    
+    // Set MVP matrix (identity)
+    float mvp_matrix[16] = {
@@ -482,6 +450,14 @@ void gl_render_frame(gl_context_t *gl, uint8_t *y_data, uint8_t *u_data, uint8_t *v_data,
         // Y texture - OPTIMIZED: minimize texture operations
         glActiveTexture(GL_TEXTURE0);
         glBindTexture(GL_TEXTURE_2D, gl->texture_y);
+        
+        // Set proper texture parameters (might have been changed by overlays)
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+        
         if (y_direct) {
@@ -513,6 +489,12 @@ void gl_render_frame(gl_context_t *gl, uint8_t *y_data, uint8_t *u_data, uint8_t *v_data,
         // U texture - OPTIMIZED: minimize texture operations  
         glActiveTexture(GL_TEXTURE1);
         glBindTexture(GL_TEXTURE_2D, gl->texture_u);
+        
+        // Set proper texture parameters
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+        
         if (u_direct) {
@@ -544,6 +526,12 @@ void gl_render_frame(gl_context_t *gl, uint8_t *y_data, uint8_t *u_data, uint8_t *v_data,
         // V texture - OPTIMIZED: minimize texture operations
         glActiveTexture(GL_TEXTURE2);
         glBindTexture(GL_TEXTURE_2D, gl->texture_v);
+        
+        // Set proper texture parameters
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+        
         if (v_direct) {
@@ -586,6 +574,11 @@ void gl_render_frame(gl_context_t *gl, uint8_t *y_data, uint8_t *u_data, uint8_t *v_data,
     }
     

+    // Check for OpenGL errors before drawing
+    GLenum error = glGetError();
+    if (error != GL_NO_ERROR) {
+        printf("OpenGL error before draw: 0x%x\n", error);
+    }
     
     // Draw quad
     glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);